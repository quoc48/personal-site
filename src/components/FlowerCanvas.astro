---
interface Props {
  /** Enable/disable animation */
  enabled?: boolean;
}

const { enabled = true } = Astro.props;
---

{enabled && (
  <canvas
    id="flower-canvas"
    aria-hidden="true"
  ></canvas>
)}

<script>
  import * as THREE from 'three';

  (function() {
    const canvas = document.getElementById('flower-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    const RESOLUTION = 128;

    // ═══════════════════════════════════════════════════
    // GLSL Shaders (exact copy from vibertthio)
    // ═══════════════════════════════════════════════════

    const planeVert = `
      precision mediump float;

      uniform mat4 projectionMatrix;
      uniform mat4 viewMatrix;
      uniform mat4 modelMatrix;

      attribute vec3 position;
      attribute vec3 normal;
      attribute vec2 uv;
      attribute float extent;

      uniform float uTime;
      uniform float uNoiseScale;
      uniform float uOffsetScale;
      uniform float uValue1;
      uniform float uValue2;

      varying float vRad;
      varying float vExtent;

      vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

      float snoise(vec2 v){
        const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                -0.577350269189626, 0.024390243902439);
        vec2 i  = floor(v + dot(v, C.yy) );
        vec2 x0 = v -   i + dot(i, C.xx);
        vec2 i1;
        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;
        i = mod(i, 289.0);
        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
        + i.x + vec3(0.0, i1.x, 1.0 ));
        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
          dot(x12.zw,x12.zw)), 0.0);
        m = m*m ;
        m = m*m ;
        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;
        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
        vec3 g;
        g.x  = a0.x  * x0.x  + h.x  * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
      }

      mat2 rotate2d(float _angle){
        return mat2(cos(_angle),-sin(_angle), sin(_angle),cos(_angle));
      }

      void main() {
        vec4 modelPos = vec4(position, 1.0);

        float rad = length(position.xy);
        float ang = atan(position.x / position.y);
        float elevation = snoise(position.xy * 5. + uTime * uNoiseScale * .2) * uOffsetScale;
        float ex = pow(sin(extent * 3.1415926), 0.1);

        modelPos.z = elevation;
        modelPos.z *= rad * 3.;
        modelPos.z *= 1. + ex;
        modelPos.xy *= sin(ang * 10. * uValue2 + uTime) * .3 + 1.0 + ex;
        modelPos.xy *= rotate2d(rad * 3.);
        modelPos.xy *= sin(uTime * rad * 5. * uValue1) + 1.0;

        gl_Position = projectionMatrix * viewMatrix * modelMatrix * modelPos;

        vRad = rad;
        vExtent = extent;
      }
    `;

    const planeFrag = `
      precision mediump float;

      varying float vRad;
      varying float vExtent;

      void main() {
        gl_FragColor = vec4(vec3(0.), pow(1. - vRad * 4., 2.) + vExtent * .2);
      }
    `;

    // ═══════════════════════════════════════════════════
    // Three.js Setup (100% matching reference)
    // ═══════════════════════════════════════════════════

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();

    // Camera: FOV 75 (not 45!), position z = -1.3
    const camera = new THREE.PerspectiveCamera(
      75,  // Reference uses 75, not 45!
      window.innerWidth / window.innerHeight
    );
    camera.position.z = -1.3;
    scene.add(camera);

    // Create group (like reference) - positioned at 1/3 from bottom
    const group = new THREE.Group();
    group.position.y = -0.35; // Move flower down to lower third of viewport
    scene.add(group);

    // Mouse tracking variables (exact same as reference)
    let mouseX = 0;
    let mouseY = 0;
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;

    // ═══════════════════════════════════════════════════
    // Plane Geometry (exact same as reference)
    // ═══════════════════════════════════════════════════

    const planeGeo = new THREE.PlaneGeometry(0.5, 0.5, RESOLUTION, RESOLUTION);
    const attrCount = (RESOLUTION + 1) * (RESOLUTION + 1);
    const extentAttr = new Float32Array(attrCount).fill(0);
    planeGeo.setAttribute('extent', new THREE.Float32BufferAttribute(extentAttr, 1));

    const planeMat = new THREE.RawShaderMaterial({
      vertexShader: planeVert,
      fragmentShader: planeFrag,
      transparent: true,
      side: THREE.DoubleSide,
      uniforms: {
        uTime: { value: 0.0 },
        uNoiseScale: { value: 2.0 },
        uOffsetScale: { value: 0.1 },
        uValue1: { value: 0.01 },
        uValue2: { value: 1.0 },
      },
    });

    const planeMesh = new THREE.Mesh(planeGeo, planeMat);
    group.add(planeMesh);

    // ═══════════════════════════════════════════════════
    // Animation Loop (exact same as reference)
    // ═══════════════════════════════════════════════════

    const clock = new THREE.Clock();

    const tick = () => {
      const dt = clock.getDelta();

      planeMat.uniforms.uTime.value = clock.getElapsedTime();

      // Decay extent (exact same as reference)
      for (let i = 0; i < planeGeo.attributes.extent.array.length; ++i) {
        planeGeo.attributes.extent.array[i] = Math.max(
          0.0,
          planeGeo.attributes.extent.array[i] - 0.3 * dt
        );
      }
      planeGeo.attributes.extent.needsUpdate = true;

      // Camera parallax (EXACT same as reference - this creates the 3D flip effect!)
      camera.position.x += (mouseX - camera.position.x) * 0.3;
      camera.position.y += (-mouseY - camera.position.y) * 0.5;  // Note: -mouseY!

      camera.lookAt(scene.position);

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    };
    tick();

    // ═══════════════════════════════════════════════════
    // Resize Handler (exact same as reference)
    // ═══════════════════════════════════════════════════

    window.addEventListener('resize', () => {
      const w = window.innerWidth;
      const h = window.innerHeight;

      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;

      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });

    // ═══════════════════════════════════════════════════
    // Mouse/Touch Handler (EXACT same as reference)
    // ═══════════════════════════════════════════════════

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const moveEventHandler = (e: MouseEvent | TouchEvent) => {
      let cX: number;
      let cY: number;

      if ('touches' in e && e.touches.length > 0) {
        cX = e.touches[0].clientX;
        cY = e.touches[0].clientY;

        // Reference calculation: ((clientX - windowHalfX) / 2) * 0.005
        mouseX = ((e.touches[0].clientX - windowHalfX) / 2) * 0.005;
        mouseY = ((e.touches[0].clientY - windowHalfY) / 2) * 0.005;
      } else if ('clientX' in e) {
        cX = e.clientX;
        cY = e.clientY;

        // Reference calculation: ((clientX - windowHalfX) / 2) * 0.005
        mouseX = ((e.clientX - windowHalfX) / 2) * 0.005;
        mouseY = ((e.clientY - windowHalfY) / 2) * 0.005;
      } else {
        return;
      }

      mouse.x = (cX / window.innerWidth) * 2 - 1;
      mouse.y = -(cY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      const intersect = raycaster.intersectObject(planeMesh);
      if (intersect != null && intersect.length > 0) {
        const nearestHit = intersect[0];
        if (nearestHit.face != null) {
          const vert0 = nearestHit.face.a;
          const vert1 = nearestHit.face.b;
          const vert2 = nearestHit.face.c;

          planeGeo.attributes.extent.array[vert0] = 1.0;
          planeGeo.attributes.extent.array[vert1] = 1.0;
          planeGeo.attributes.extent.array[vert2] = 1.0;
          planeGeo.attributes.extent.needsUpdate = true;
        }
      }
    };

    window.addEventListener('mousemove', moveEventHandler);
    window.addEventListener('touchmove', moveEventHandler);
  })();
</script>

<style>
  #flower-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    opacity: 0.7;
  }
</style>
